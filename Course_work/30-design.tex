\chapter{Конструкторский раздел}
\label{cha:design}
\section{Технология сбора данных}
Первостепенную важность для оценки эффективности параллельной программы имеет информация о взаимодействиях между её отдельными частями (процессами) и долях времён, затраченных процессами на взаимодействие и ожидание. Для  получения этой информации во время выполнения программы вызовы примитивов взаимодействия должны соответствующим образом обрабатываться средством трассировки. Рассмотрим основные подходы.
\subsection{Синтаксический анализ исходных текстов} С помощью синтаксического анализатора в исходном тексте программы выявляются вызовы примитивов взаимодействия и заменяются вызовами профилирующей библиотеки. Основным преимуществом этого метода является возможность для каждого вызова передать трассировщику положение этого вызова в исходном тексте, имена переменных и другую информацию, не доступную во время выполнения. В результате чего, при анализе трассы программы можно будет легко сопоставить вызовы библиотеки передачи сообщений с исходным кодом. Также есть возможность легко вернуться к «рабочему» варианту программы, без трассирующих вызовов, т.е. не использовать разбор кода. Из недостатков следует выделить: сложность реализации, зависимость от языка программирования, дополнительный шаг компиляции, увеличение объёма трассы.
\subsection{Статическое связывание с библиотекой профилировщика} В этом случае изменения исходного кода не требуются. Вместо этого на этапе связывания вызовы библиотеки передачи сообщений подменяются вызовами профилировщика. Конфликт имён при этом разрешается либо за счёт многоэтапного связывания, либо за счёт «слабых» (week) связей. Как и в предыдущем случае, здесь не требуется вносить изменения в исходный код, но при этом не требуется проводить сложный анализ исходного кода.
\subsection{Определение точек трассировки во время выполнения} Метод основан на анализе частоты и шаблонов вызовов функций во время выполнения программы. При этом двоичный код программы компилируется стандартным образом, а профилирующие вызовы вставляются автоматически на основе реального поведения программы. Этот метод можно использовать при невозможности перекомпиляции программы. Но придётся столкнуться с такими проблемами как: зависимость от конкретной платформы, отсутствие возможности прямо указать необходимость профилирования того или иного участка программы, сложность сопоставления обнаруженного узкого места с исходным кодом.
Кроме получения информации о системных вызовах программы, также необходимо предоставить пользователю возможность указывать собственные временнЫе метки. Это позволяет определить время выполнения логических участков программы, а также упростить связь событий трассы с исходным кодом.
Работа над выявлением узких мест в программе как правило ведётся итерационно, со всё большим уровнем детализации. При этом внимание разработчика сосредотачивается на отдельных участках программы, оставляя другие участки за кадром. Чтобы снизить объём трассы, средство трассировки должно допускать трассировку только части программы, иметь средства для приостановки и возобновления трассировки \cite{book3}.
Изложенным требованиям удовлетворяет библиотека PICL, использующая для трассировки интерфейс профилирования MPI.
\subsection{PICL}
PICL (Portable Instrumented Communication Library)  - библиотека подпрограмм, разработанная в Oak Ridge National Laboratory (ORNL), которая реализует общий
нтерфейс передачи сообщений на множестве многопроцессорных архитектур. Программы, написанные с помощью примитивов PICL вместо команд среды взаимодействия, являются переносимыми в том смысле, что они могут выполняться на любой машине, для которой есть реализация PICL.\\
PICL была разработана для:
\begin{enumerate} 
\item Обеспечения переносимости между разными платформами с минимальными накладными расходами;
\item Получения трассировочных данных по межпроцессным взаимодействиям и пользовательским событиям, также с минимальными накладными расходами для избежания влияния на поведение исследуемой задачи, и
\item Обеспечения переносимости на новые системы, простого расширения для использования преимуществ новых команд конкретной системы
\end{enumerate} 
Для достижения этих целей PICL реализована как библиотека подпрограмм языка C с машинно-независимым трассировочным слоем и машинно-зависимым слоем, отображающимся на команды конкретной системы (когда это возможно). PICL  была открыта для широкого использования в марте 1989. Её разработка продолжалась, и были выпущены несколько релизов, добавляющие новые коммуникационные и трассировочные команды и поддержку новых вычислительных систем.
В последней версии PICL запись трассы имеет формат, показанный в таблице \ref{tab:tbl1}. Для каждой записи обязательными являются первые шесть полей, но если количество полей данных равно нулю, то дескриптор данных исключается.

\begin{table}[h!]
	\caption{\label{tab:tbl1}Формат записи трассы PICL}
\begin{tabular}{|l|l|}
	%	&\makebox[3em]{6/3}&\makebox[3em]{6/4}
	\hline
	Наименование поля & Назначение \\
	\hline\hline
	тип записи&тип информации в записи
	\\\hline
	тип события &тип события, с которым связана запись
	\\\hline
	отметка времени&когда информация была истинной\\\hline
	идентификатор процессора
	&процессор, с которым связана информация
	\\\hline
	идентификатор процесса	
	&процесс, с которым связана информация	
	\\\hline
	количество полей данных	
	&количество дополнительных полей данных, связанных \tabularnewline & с данными типами записи и события	
	\\\hline
	дескриптор данных	
	&формат полей данных
    \\\hline
    данные	
    &дополнительные поля данных
    \\\hline

\end{tabular}
\end{table}
Основное внимание в этом формате уделено записи информации, связанной как с системными, так и с пользовательскими событиями, при этом каждая запись связана с определённым типом события. Порядок полей записи отражает важность полей для систем, обрабатывающих данные: что, где, когда и ассоциированные с событием данные. Если тип записи или события не знаком системе, то данную запись можно пропустить. Но если система хочет получить информацию из записи, то ей для этого всё предоставлено.

Формат PICL предусматривает ранение данных в текстовом виде. Все поля состоят из символов кодировки ASCII и разделены пробелами. Тип записи, тип события, идентификаторы процессора и процесса, количество полей данных – целые числа. Дескриптор данных – это либо целое число, либо символьная строка переменной длины, заключённая в двойные кавычки. Формат полей данных определяется дескриптором данных. Временная метка – число с плавающей точкой, разрешение которой зависит от единиц измерения (например, секунд) и точности таймера на машине, на которой генерируется трасса.

    Практика показала, что текстовый формат очень полезен для переносимости, поиска и исправления ошибок в трассе и для возможной работы с трассой без помощи средств визуализации, и он не препятствует сжатию файлов, если это необходимо. При этом PICL использует двоичное представление данных при внутренней обработке для экономии места и избежания накладных расходов при преобразовании данных \cite{book4}.
Значения полей и их интерпретация приведены в таблице \ref{tab:tbl2}
\begin{table}[h!]
	\caption{\label{tab:tbl2} Значения полей записи}
	\begin{tabular}{|l|l|}
		%	&\makebox[3em]{6/3}&\makebox[3em]{6/4}
		\hline
		Поле & Назначение \\
		\hline\hline
		тип записи& $\geq0$ пользовательский тип записи\tabularnewline & $\le0$ стандартный системный тип записи
		\\\hline
		тип события & $\geq0$ пользовательское событие или определённое \tabularnewline & пользователем подмножество событий\tabularnewline & $=-1$ относится ко всем событиям \tabularnewline &(глобальная информация)
		\tabularnewline & $<-1$ системное событие или \tabularnewline &системное подмножество событий
		\\\hline
		временная метка& $\geq0$идентификатор конкретного процессора\tabularnewline & $=-1$ относится ко всем процессорам \tabularnewline &(глобальная информация)
		\tabularnewline & $<-1$ относится к подмножеству процессоров
		\\\hline
		идентификатор процесса
		&$\geq0$ идентификатор процесса\tabularnewline & на заданном процессоре\tabularnewline & $=-1$ относится ко всем процессам\tabularnewline & на заданном процессоре \tabularnewline &(глобальная информация)
		\tabularnewline & $<-1$ относится к подмножеству процессов\tabularnewline & на указанном процессоре
		\\\hline
		количество полей данных	
		&количество дополнительных полей данных	
		\\\hline
          дескриптор данных
		& если заключён в двойные кавычки,\tabularnewline & то формат функции scanf(),
		иначе:\tabularnewline &
		$=0$  символ ("\%c") \tabularnewline & $=1$ cтрока ("\%s") \tabularnewline &
		$=2$ целое число ("\%d") \tabularnewline &
		$=3$ длинное целое число  ("\%ld") \tabularnewline &
	    $=4$ число с плавающей точкой одинарной точности  ("\%f") \tabularnewline &
	    $=5$ число с плавающей точкой двойной точности   ("\%lf") \tabularnewline &
	    $>6$ другой предопределённый формат данных \tabularnewline &
	    
		
		\\\hline
	
	\end{tabular}
\end{table}
Идентификаторы процесса и процессора определяют «местоположение» события. Хотя обычно процессы на каждом процессоре нумеруются последовательно начиная с 0, может быть полезно нумеровать процессы независимо от процессора, прямо поддерживая как процессоро-зависимый, так и процессоро-независимый подход к визуализации. (Заметим, что на данный момент PICL не поддерживает много процессов на одном (последовательном) процессоре. Поле идентификатора процесса было введено для совместимости с системами, которые поддерживают эту модель и для возможности будущего расширения PICL. В трассах текущего формата идентификатору процесса присваивается либо действительной PID, т.е. номер процесса, заданный операционной системой, либо -1.)
\subsection{Технология обработки данных}
Формат трассы PICL, рассмотренный в предыдущем параграфе, предполагает единый формат записи как для событий профилируемой программы, так и для управляющих событий. Управляющие события описывают изменения формата трассы, которые должны быть учтены при её последующем разборе. Характерным примером такого события может служить описание нового формата данных.

Для программы, обрабатывающей эти данные более удобным было бы представление их в виде событий, характеризуемых временным интервалом, типом события и идентификатором процесса.
\section{Серверная часть}
Для хранения файлов трасс формата PICL была спроектирована база данных
\subsection{Базы данных}
\begin{lstlisting}[language=SQL]
CREATE TABLE Tracks ( 
filename VARCHAR(50) NOT NULL,
typeRecord INT NOT NULL,
typeEvent INT NOT NULL,
time FLOAT NOT NULL,
prid INT NOT NULL,
pid INT NOT NULL,
numData INT NOT NULL,
data VARCHAR(200)
) ENGINE = INNODB DEFAULT CHARSET=utf8;
\end{lstlisting}
Так же были спроектирована вспомогательные базы данных для хранения информации о событиях MPI и телеметрии работы пользователя.
\begin{lstlisting}[language=SQL]
CREATE TABLE Codes(
code  INT NOT NULL ,
name  VARCHAR(50) NOT NULL  PRIMARY KEY,
description TEXT,
category TEXT
) ENGINE = INNODB DEFAULT CHARSET=utf8;
CREATE TABLE Telemetry(
username VARCHAR(50) NOT NULL,
timeRequest  DATETIME NOT NULL,
timeStart FLOAT NOT NULL,
timeEND  FLOAT NOT NULL
) ENGINE = INNODB DEFAULT CHARSET=utf8;
\end{lstlisting} 
Для хранения данных пользователя была создана модель пользоватля в 
\begin{lstlisting}[language=c++]
mongoose.model('User', new Schema({ 
    name: String, 
    password: String, 
    files: []
}));
\end{lstlisting} 
\subsection{API для взаимодействия с сервером}
Была придумано API взаимодействия между клиентом и сервером. Безопастность взаимодействия гарантируется тем, что взаимодействия осуществляется на основе токенов. Все запросы, кроме запроса на авторизацию, требуют содержания в себе уникального токена.Токен дается клиенту после успешного прохождения авторизации.
\begin{lstlisting}[language=c++]
[GET] /authenticate
Авторизация
Аргументы
)name - логин
)password - пароль
[GET] /getFile
Получение куска содержанимого файла
Аргументы
)filename - имя файла
)offset - отступ от начала файла
)limit - количество получаемых записей
)timeMin - время начала записей
)timeMax - время конца записей
[GET] /getTimeBorders
Получение временного интервала трассы
Аргументы
)filename - имя файла
[GET] /getFileList
Получение списка файлов, доступных для данного пользователя
Аргументы
)name - логин
[GET] /getNumRecords
Получение количества записей для данного файла
Аргументы
)filename - имя файла
)timeMin - время начала записей
)timeMax - время конца записей 
[GET] /getCodeInfo
Получение информации о событие по его коду
Аргументы
)code - код события
[GET] /getNumProcess
Получение максимального количества процессов, которые записаны в файл
Аргументы
)filename - имя файла
\end{lstlisting}

%%% Local Variables:

%%% mode: latex
%%% TeX-master: "rpz"
%%% End:
%--количество цветов
%||количество пикселей